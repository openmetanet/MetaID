 # MetaID Protocol Introduction

| brfc         | title           | authors                | version |
| ------------ | --------------- | ---------------------- | ------- |
| 224b9f82f330 | MetaID Protocol | ShowPayTeam MetaSVTeam | V0.1    |


## 1. Overview

 MetaID is a sub-protocol of Metanet[1], which is a protocol proposed to solve the inability to organize the users' data between different applications/wallets on BSV network. 

We hope that with more and more wallets and applications supporting the MetaID protocol, the following MetaID goals can be achieved:

- Users only need one master private key  on the BSV network to use all MetaID-enabled applications/wallets;

- The user's basic information and application/transaction data are recorded on the Metanet nodes that he owns, so that the users' data has nothing to do with the wallet side and the application side.

- Different applications can access the same protocol data to eliminate the information island between applications;

- The data of different protocols can be combined with each other under the MetaID association, and the BSV application development work is greatly reduced;

MetaID is flexible and extensible, and application / protocol maker can easily add or modify their required protocols to build up various applications.



## 2. The MetaID protocol

The overall protocol format of MetaID is:

```
<Metanet Flag><P(node)><TxID(parent)><MetaID Flag><node_name><data><encrypt><version><data_type><encoding> 
```

The first three parts are the standard parts of the Metanet protocol, and the last seven parts are the extension parts of MetaID protocol. The MetaID protocol follows the MetaNet protocol and is created by including OP_0 OP_Return opcodes.



### 2.1 The standard parts of Metanet protocol

The first three parts are:

```
<Metanet Flag><P(node)><TxID(parent)>
```

Above is the standard format of Metanet protocol. The specific meanings are as follows:：

- < Metanet Flag >Always be "meta";

- < P(node)  >It is a public key；

- < TxID(parent) >It is the transaction ID of parent node

For more details of the Metanet, please refer to the Metanet protocol white paper.



### 2.2 The extension parts of MetaID

The last seven parts are:

```
 <MetaID Flag><node_name><data><encrypt><version><data_type><encoding>  
```

Above is the content added by MetaID as the Metanet sub-protocol. The specific meanings are as follows:


|         key | value                                                        |
| ----------: | ------------------------------------------------------------ |
| MetaID Flag | Always be "MetaID"                                           |
|   node_name | The name of the node, required field.                        |
|        data | Store the data content corresponding to the node.            |
|     encrypt | Indicate whether the content of the node is encrypted. The current version of the protocol supports two methods: 0 is no encryption; 1 is ECIES encryption, that is, the encryption key is the public key of the corresponding node, and the private key of the corresponding node is used for decryption.  Default value is 0. |
|     version | The version of the data. Different version means that the format of the data content is different. |
|   data_type | The corresponding type of the data. As listed at https://www.iana.org/assignments/media-types/media-types.xhtml. (Optional, default is "text/plain") |
|    encoding | The corresponding encoding of the data. As listed at https://www.iana.org/assignments/character-sets/character-sets.xhtml. (Optional, default is "UTF-8") |



The standard MetaID transaction format should be as follows:

  TxID <sub>node</sub> 
| Inputs | Outputs |
| ---- | --------------- |
| < Sig P<sub>parent</sub> > <P<sub>parent</sub> > | OP_0 OP_RETURN < Metanet Flag > < P<sub>node</sub> > < TxID<sub>parent</sub> > < MetaID Flag > < node_ame > < data >< encrypt >< version >< data_type >< encoding > |



## 3. The structure of MetaID

There are only two child nodes under the root node of MetaID, namely "Info" and "Protocols".

- "Info" is the user's basic information node. Recording basic information such as user name and avatar, etc.
- "Protocols" is the node stores protocols. Recording transactions generated by users using related protocols.

![image](https://github.com/showMoneyapp/MetaID/blob/master/doc/en/res/en_1.png)


"Root","Info" and "Protocols" nodes are required for MetaID. These three nodes are not allowed to change their names and do not accept version update operation.



### 3.1 The Root Node

The "Root" node is root node of MetaID. According to the Metanet protocol,  set TxID<sub>parent </sub> to be NULL for the root node.

When constructing a root node, the node_ame is fixed at "Root". The following is an example of building a root node:

```
OP_0 OP_RETURN meta <P(node)> NULL MetaID Root NULL NULL NULL NULL NULL NULL
```

Since it is a root node, TxID <sub> parent </sub> needs to be NULL. Then set the name of the root node to "Root", and all subsequent parts are not required, so they can all be set to NULL.

The public key generation convention for the P<sub> node </sub> is using the Hierarchical Deterministic scheme [2], and the public key of the root node contract uses the 0/0 path of HD scheme.



### 3.2 The Info node

The "Info" node is a node that stores basic user information, and the node_name is always be "Info".

The structure of the "Info" node is similar to the "Root" node, but the TxID<sub>parent</sub>  needs to point to the transaction of the "Root" node and set the node_name to "Info". The following is an example of building an "Info" node:

```
OP_0 OP_0 OP_RETURN meta <P(node)> <TxID(Root)> MetaID Info NULL NULL NULL NULL NULL NULL
```



**About the basic user information**

In this version of the protocol, the basic user information is placed under the "Info" node. The "Info" node contains the following five child nodes:

- name: Means the user name.(set encrypt to 0 and default encoding is text/plain)
- avatar: Means the avatar image of the user. (set encrypt to 0 and default encoding is binary)
- email: Means user email.(set encrypt to 0 and default encoding is text/plain)
- phone: Means the phone number of the user.(suggest set encrypt to 1 and default encoding is text/plain)
- Bio: Means the bio of the user.(set encrypt to 0 and default encoding is text/plain)

The structure diagram is as follows:


![image](https://github.com/showMoneyapp/MetaID/blob/master/doc/en/res/en_2.png)


It is acceptable that the node is not created or the data of the node is empty or NULL. However, it is recommended that when a new MetaID user is newly applied, at least the name node must be set to determine the user name.

The following is an example of building a "name" node. We want to set the user's name to "Alice". Just construct a MetaID transaction, point its parent node to the Info node, set node_name to "name", and data to "Alice", as shown below:

```
OP_0 OP_RETURN meta <P(node)> <TxID(Info)> MetaID name Alice 0 1 NULL NULL
```

And the "avatar" node stores user's avatar image, and the encoding of the data is  binary. The construction can refer to the following:

```
OP_0 OP_RETURN meta <P(node)> <TxID(Info)> MetaID avatar <IMAGE BUFFER> 0 1 image/png binary
```

All other nodes can be constructed in a similar way. It should be noted that if certain information such as the phone number needs to be encrypted, just set encrypt to 1, and then use ECIES  to encrypt the relevant information with the public key, so that only the user could use his/her private key to decrypt it.



### 3.3 The Protocols node

The "Protocols" node records the user's transactions when using various third-party protocols. The child nodes under the Protocols node are third-party protocol nodes, and their node_name should be the protocol name set by the third-party. The child nodes under the protocol nodes are the specific transactions generated by users using the protocol/application. The structure is as follows:

![image](https://github.com/showMoneyapp/MetaID/blob/master/doc/en/res/en_3.png)

Since the protocol nodes under the “Protocols” node are open for everyone, all application parties can build their own protocols. Therefore, the number of child nodes under “Protocols” is unlimited, and the structure under each protocol node is determined by the protocol maker / application. However, it is necessary to ensure that the identity of the protocol node is globally unique.



#### 3.3.1 The protocol nodes

**About the the identity convention for protocols**

When constructing a new protocol node,  the node_name is set to the protocol name. There is no restriction on the name of the protocol, and the application party can form a protocol name that is easy to read and understand according to its own needs. But in order to solve the problem of naming conflicts, the data part needs to be set to a 12-byte hash value, called Hash ID. Since there is no centralized organization to check whether the protocol name is duplicated, it is necessary to retain the Hash ID corresponding to the protocol of the data name. The Hash ID generation method comes from the BRFC ID [3] protocol specification. The final result must be a 12-byte hash. For how to generate BRFC ID, please refer to the BRFC ID specification document.

The unique identity scheme of the  protocol nodes under Protocols is:

```
node_name+HashID
```
For example, the BRFC ID of a protocol is "3065510ee0dd", and the construction reference is as follows:

```
OP_0 OP_RETURN meta <P(node)> <Txid(Protocols)> MetaID SampleProtocol 3065510ee0dd 0 1 text/plain UTF-8
```

When dealing with the problem of naming conflicts in actual data, node_name + data can be used as a globally unique identity. when a unique identity is required, such as URI positioning, concatenating node_name and data, ie SampleProtocol3065510ee0dd, can be used to locate the node.

**Convention on the structure of protocol nodes**

The structure of each protocol  node is determined by the protocol/ application builders. The structure of a protocol node can be a flat one-layer structure or a complex multi-layer structure. If the business allows,  the protocol/ application maker should document and publish the protocol specs, so that other application builders / data service providers can use and parse it.

It should be noted that although the structure of these nodes is determined by the protocol  / applicator builders, the creation of the relevant nodes is still created by the user and is mastered by the user. The user only records the protocol data related to himself.

**About the privacy model of protocols**

The privacy model of a protocol is determined by the protocol Maker / application party. If users do not want their data to be disclosed, it is recommended to consider the following ways:

- Set the node's property "encrypt" to 1. In this way, the data can only be viewed by users themselves.
- The protocols maker/application party could consider use a kind of key-agreement protocol,such as ECDH to encrypt the protocol data. In this way, only users and application can view the data, and users can authorize or delegate applications to authorize third-parties to access the data.

- If the protocol makers/Applications are particularly sensitive to user privacy, they could build an orphan application data set, and then associated with the MetaID main tree through a bridge node which would no be disclosed.



#### 3.3.2 The transaction nodes under protocol node

The child nodes under each protocol are specific transactions generated by users using the protocol/applicaiton, and each specific transaction is recorded in a protocol transaction node.

"data" part is the place to store protocol data. The protocol data is parsed by the application party according to the protocol Spec.

The node_name of the  transaction node needs to be unique within the same level in the domain tree, so that it can be easily searched by URI in the future. For example, you can use the public key as the node_name.

Assuming that a certain MetaID transaction belongs to the SampleProtocol protocol, its data format is Json, and the data content is as follows:

```
{"content":"This is test content","title":"This is a title"}
```
Then, the OP_RETURN construction is as follows:

```
OP_0 OP_RETURN meta <P(node)> <Txid(SampleProtocol)> MetaID <node_name> {"content":"This is test content","title":"This is a title"} 0 1 applicaiton/json UTF-8
```

It is worth noting that the "version" content  in the protocol transaction represents the protocol version that it follows, and different version  represent that the data content may be different. When analyzing data, you need to do different analysis according to different version. for the above example, the generated Metanet tree structure is as follows:

![image](https://github.com/showMoneyapp/MetaID/blob/master/doc/en/res/en_4.png)



## 4. Summarize

The MetaID can provide users and applications with the following conveniences:

- Constructed a Metanet tree that is really owned by the user. The Metanet tree records the user's basic information and all transactions  of the protocols.
- Users only need to safe keep a master private key (or one mnemonic) to use all the wallets that support MetaID. The wallet which supports MetaID can restore all application data of the user on the blockchain. 
- The application side only needs to trawl the blockchian for all the transactions of its users on its protocol, record the relevant qualified transactions, and aggregate and organize to present the entire application data.
- Multiple applications can use the same protocol, and an application can also aggregate multiple protocols. Application development is more flexible and development work is greatly reduced.



## 5. Reference
| Number | Reference  |
| ---- | --------------- |
|   [1]   | Metanet technical summary https://nchain.com/app/uploads/2019/06/The-Metanet-Technical-Summary-v1.0.pdf |
|[2]| BIP32https://github.com/moneybutton/bips/blob/master/bip-0032.mediawiki |
|   [3]  | BRFC ID Assignment http://bsvalias.org/01-02-brfc-id-assignment.html |
